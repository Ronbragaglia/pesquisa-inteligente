# -*- coding: utf-8 -*-
"""OpenDeepResearcher

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1g6sTT6VTmZVypF5VEDsmmAUJkJZcLaOf
"""

!pip install nest_asyncio gradio aiohttp


import nest_asyncio
nest_asyncio.apply()

import asyncio
import aiohttp
import gradio as gr
import json


OPENROUTER_API_KEY = "SUA_OPENROUTER_API_KEY_AQUI"
SERPAPI_API_KEY = "SUA_SERPAPI_API_KEY_AQUI"
JINA_API_KEY = "SUA_JINA_API_KEY_AQUI"


OPENROUTER_URL = "https://openrouter.ai/api/v1/chat/completions"
SERPAPI_URL = "https://serpapi.com/search"
JINA_BASE_URL = "https://r.jina.ai/"


DEFAULT_MODEL = "anthropic/claude-3.5-haiku"



async def call_openrouter_async(session, messages, model=DEFAULT_MODEL):
    """Chama a API da OpenRouter para gerar respostas da IA."""
    headers = {
        "Authorization": f"Bearer {OPENROUTER_API_KEY}",
        "X-Title": "OpenDeepResearcher",
        "Content-Type": "application/json"
    }
    payload = {
        "model": model,
        "messages": messages
    }
    try:
        async with session.post(OPENROUTER_URL, headers=headers, json=payload) as resp:
            if resp.status == 200:
                result = await resp.json()
                return result.get('choices', [{}])[0].get('message', {}).get('content', "")
            else:
                print(f"⚠ Erro OpenRouter API: {resp.status}")
                return None
    except Exception as e:
        print("⚠ Erro ao chamar OpenRouter:", e)
        return None

async def perform_search_async(session, query):
    """Realiza uma pesquisa no Google usando SERPAPI."""
    params = {
        "q": query,
        "api_key": SERPAPI_API_KEY,
        "engine": "google"
    }
    try:
        async with session.get(SERPAPI_URL, params=params) as resp:
            if resp.status == 200:
                results = await resp.json()
                return [item.get("link") for item in results.get("organic_results", []) if "link" in item]
            else:
                print(f"⚠ Erro SERPAPI: {resp.status}")
                return []
    except Exception as e:
        print("⚠ Erro ao realizar pesquisa no SERPAPI:", e)
        return []

async def fetch_webpage_text_async(session, url):
    """Obtém o texto da página via API Jina."""
    headers = {"Authorization": f"Bearer {JINA_API_KEY}"}
    try:
        async with session.get(f"{JINA_BASE_URL}{url}", headers=headers) as resp:
            return await resp.text() if resp.status == 200 else ""
    except Exception as e:
        print("⚠ Erro ao buscar texto da página:", e)
        return ""

async def generate_search_queries_async(session, user_query):
    """Gera consultas de pesquisa otimizadas para coletar mais dados relevantes."""
    prompt = f"""
    Gere até quatro consultas de pesquisa precisas e distintas baseadas na seguinte consulta:
    "{user_query}".
    Retorne apenas uma lista Python de strings, ex: ['consulta1', 'consulta2'].
    """
    messages = [{"role": "user", "content": prompt}]
    response = await call_openrouter_async(session, messages)
    try:
        return eval(response) if isinstance(eval(response), list) else []
    except:
        return []

async def generate_final_report_async(session, user_query, all_contexts):
    """Gera um relatório final detalhado usando os dados coletados."""
    context_combined = "\n".join(all_contexts)
    prompt = f"""
    Gere um relatório detalhado baseado nas informações coletadas e na seguinte pergunta:
    "{user_query}".
    O relatório deve ser estruturado, objetivo e com insights claros.
    """
    messages = [{"role": "user", "content": prompt}]
    return await call_openrouter_async(session, messages) or "Nenhum relatório gerado."


async def async_research(user_query, iteration_limit):
    """Executa o fluxo de pesquisa automatizado, iterando conforme necessário."""
    aggregated_contexts = []
    log_messages = []
    async with aiohttp.ClientSession() as session:
        log_messages.append("🔄 Gerando consultas iniciais...")
        search_queries = await generate_search_queries_async(session, user_query)
        if not search_queries:
            return "⚠ Nenhuma consulta de pesquisa gerada.", "\n".join(log_messages)

        log_messages.append(f"🔍 Consultas iniciais: {search_queries}")

        for iteration in range(int(iteration_limit)):
            log_messages.append(f"\n🌀 Iteração {iteration + 1}")
            tasks = [perform_search_async(session, q) for q in search_queries]
            search_results = await asyncio.gather(*tasks)
            unique_links = list(set(link for sublist in search_results for link in sublist))

            log_messages.append(f"🔗 {len(unique_links)} links encontrados.")

            page_tasks = [fetch_webpage_text_async(session, link) for link in unique_links]
            page_results = await asyncio.gather(*page_tasks)

            useful_texts = [text for text in page_results if text.strip()]
            aggregated_contexts.extend(useful_texts)

            if not useful_texts:
                log_messages.append("⚠ Nenhuma página útil encontrada nesta iteração.")
                break

        log_messages.append("\n📜 Gerando relatório final...")
        final_report = await generate_final_report_async(session, user_query, aggregated_contexts)
        return final_report, "\n".join(log_messages)

def run_research(user_query, iteration_limit=10):
    """Executa a pesquisa chamando a função assíncrona e retorna os resultados."""
    return asyncio.run(async_research(user_query, iteration_limit))



def gradio_run(user_query, iteration_limit):
    try:
        final_report, logs = run_research(user_query, int(iteration_limit))
        return final_report, logs
    except Exception as e:
        return f"⚠ Erro: {e}", ""

iface = gr.Interface(
    fn=gradio_run,
    inputs=[
        gr.Textbox(label="🔍 Tópico da Pesquisa"),
        gr.Number(value=5, label="🔄 Máx. Iterações"),
    ],
    outputs=[
        gr.Textbox(label="📜 Relatório Final"),
        gr.Textbox(label="📌 Logs de Execução"),
    ],
    title="🔎 Assistente de Pesquisa Inteligente",
    description="Forneça um tópico e um número máximo de iterações. O sistema irá buscar, processar e gerar um relatório final baseado em IA.",
)

iface.launch()

!git config --global user.name "Ronbragaglia"
!git config --global user.email "Ronebragaglia23@yahoo.com"

!git clone https://github.com/Ronbragaglia/pesquisa-inteligente.git

!mv * SEU_REPOSITORIO/