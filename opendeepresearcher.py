# -*- coding: utf-8 -*-
"""OpenDeepResearcher

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1g6sTT6VTmZVypF5VEDsmmAUJkJZcLaOf
"""

!pip install nest_asyncio gradio aiohttp


import nest_asyncio
nest_asyncio.apply()

import asyncio
import aiohttp
import gradio as gr
import json


OPENROUTER_API_KEY = "SUA_OPENROUTER_API_KEY_AQUI"
SERPAPI_API_KEY = "SUA_SERPAPI_API_KEY_AQUI"
JINA_API_KEY = "SUA_JINA_API_KEY_AQUI"


OPENROUTER_URL = "https://openrouter.ai/api/v1/chat/completions"
SERPAPI_URL = "https://serpapi.com/search"
JINA_BASE_URL = "https://r.jina.ai/"


DEFAULT_MODEL = "anthropic/claude-3.5-haiku"



async def call_openrouter_async(session, messages, model=DEFAULT_MODEL):
    """Chama a API da OpenRouter para gerar respostas da IA."""
    headers = {
        "Authorization": f"Bearer {OPENROUTER_API_KEY}",
        "X-Title": "OpenDeepResearcher",
        "Content-Type": "application/json"
    }
    payload = {
        "model": model,
        "messages": messages
    }
    try:
        async with session.post(OPENROUTER_URL, headers=headers, json=payload) as resp:
            if resp.status == 200:
                result = await resp.json()
                return result.get('choices', [{}])[0].get('message', {}).get('content', "")
            else:
                print(f"âš  Erro OpenRouter API: {resp.status}")
                return None
    except Exception as e:
        print("âš  Erro ao chamar OpenRouter:", e)
        return None

async def perform_search_async(session, query):
    """Realiza uma pesquisa no Google usando SERPAPI."""
    params = {
        "q": query,
        "api_key": SERPAPI_API_KEY,
        "engine": "google"
    }
    try:
        async with session.get(SERPAPI_URL, params=params) as resp:
            if resp.status == 200:
                results = await resp.json()
                return [item.get("link") for item in results.get("organic_results", []) if "link" in item]
            else:
                print(f"âš  Erro SERPAPI: {resp.status}")
                return []
    except Exception as e:
        print("âš  Erro ao realizar pesquisa no SERPAPI:", e)
        return []

async def fetch_webpage_text_async(session, url):
    """ObteÌm o texto da paÌgina via API Jina."""
    headers = {"Authorization": f"Bearer {JINA_API_KEY}"}
    try:
        async with session.get(f"{JINA_BASE_URL}{url}", headers=headers) as resp:
            return await resp.text() if resp.status == 200 else ""
    except Exception as e:
        print("âš  Erro ao buscar texto da paÌgina:", e)
        return ""

async def generate_search_queries_async(session, user_query):
    """Gera consultas de pesquisa otimizadas para coletar mais dados relevantes."""
    prompt = f"""
    Gere ateÌ quatro consultas de pesquisa precisas e distintas baseadas na seguinte consulta:
    "{user_query}".
    Retorne apenas uma lista Python de strings, ex: ['consulta1', 'consulta2'].
    """
    messages = [{"role": "user", "content": prompt}]
    response = await call_openrouter_async(session, messages)
    try:
        return eval(response) if isinstance(eval(response), list) else []
    except:
        return []

async def generate_final_report_async(session, user_query, all_contexts):
    """Gera um relatoÌrio final detalhado usando os dados coletados."""
    context_combined = "\n".join(all_contexts)
    prompt = f"""
    Gere um relatoÌrio detalhado baseado nas informacÌ§oÌƒes coletadas e na seguinte pergunta:
    "{user_query}".
    O relatoÌrio deve ser estruturado, objetivo e com insights claros.
    """
    messages = [{"role": "user", "content": prompt}]
    return await call_openrouter_async(session, messages) or "Nenhum relatoÌrio gerado."


async def async_research(user_query, iteration_limit):
    """Executa o fluxo de pesquisa automatizado, iterando conforme necessaÌrio."""
    aggregated_contexts = []
    log_messages = []
    async with aiohttp.ClientSession() as session:
        log_messages.append("ğŸ”„ Gerando consultas iniciais...")
        search_queries = await generate_search_queries_async(session, user_query)
        if not search_queries:
            return "âš  Nenhuma consulta de pesquisa gerada.", "\n".join(log_messages)

        log_messages.append(f"ğŸ” Consultas iniciais: {search_queries}")

        for iteration in range(int(iteration_limit)):
            log_messages.append(f"\nğŸŒ€ IteracÌ§aÌƒo {iteration + 1}")
            tasks = [perform_search_async(session, q) for q in search_queries]
            search_results = await asyncio.gather(*tasks)
            unique_links = list(set(link for sublist in search_results for link in sublist))

            log_messages.append(f"ğŸ”— {len(unique_links)} links encontrados.")

            page_tasks = [fetch_webpage_text_async(session, link) for link in unique_links]
            page_results = await asyncio.gather(*page_tasks)

            useful_texts = [text for text in page_results if text.strip()]
            aggregated_contexts.extend(useful_texts)

            if not useful_texts:
                log_messages.append("âš  Nenhuma paÌgina uÌtil encontrada nesta iteracÌ§aÌƒo.")
                break

        log_messages.append("\nğŸ“œ Gerando relatoÌrio final...")
        final_report = await generate_final_report_async(session, user_query, aggregated_contexts)
        return final_report, "\n".join(log_messages)

def run_research(user_query, iteration_limit=10):
    """Executa a pesquisa chamando a funcÌ§aÌƒo assiÌncrona e retorna os resultados."""
    return asyncio.run(async_research(user_query, iteration_limit))



def gradio_run(user_query, iteration_limit):
    try:
        final_report, logs = run_research(user_query, int(iteration_limit))
        return final_report, logs
    except Exception as e:
        return f"âš  Erro: {e}", ""

iface = gr.Interface(
    fn=gradio_run,
    inputs=[
        gr.Textbox(label="ğŸ” ToÌpico da Pesquisa"),
        gr.Number(value=5, label="ğŸ”„ MaÌx. IteracÌ§oÌƒes"),
    ],
    outputs=[
        gr.Textbox(label="ğŸ“œ RelatoÌrio Final"),
        gr.Textbox(label="ğŸ“Œ Logs de ExecucÌ§aÌƒo"),
    ],
    title="ğŸ” Assistente de Pesquisa Inteligente",
    description="FornecÌ§a um toÌpico e um nuÌmero maÌximo de iteracÌ§oÌƒes. O sistema iraÌ buscar, processar e gerar um relatoÌrio final baseado em IA.",
)

iface.launch()

!git config --global user.name "Ronbragaglia"
!git config --global user.email "Ronebragaglia23@yahoo.com"

!git clone https://github.com/Ronbragaglia/pesquisa-inteligente.git

!mv * SEU_REPOSITORIO/